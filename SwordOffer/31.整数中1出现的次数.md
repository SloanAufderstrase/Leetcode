Description:

输入一个整数n,求从1到n这n个整数的十进制表示中1出现的次数

leetcode: 233

思路： 
暴力解法O(n)，当n>10^9之后会超时

number = 1432
One's digit: 1432 / 10 = 143    143 + 1  --> (11, 21, 31,...1431) + 1 (数字1)
Ten's digit: 143 / 10 = 14      14 * 10 + 10   --> (110, 111, 112,...,119, 210, 211, 212, .219,.., 1419) + (10, 11,12,..19)
Hun's digit: 14 / 10 = 1        1 * 100 + 100  --> (1100, 1101, ... 1199) + (100, 101, ... 199)
Tho's digit: 1432 % 1000 = 432  432 + 1 = 433 --> (1000, 1001, 1002, ... 1432)

当该位为0时，出现1的次数为  n / factor * factor  
当改位位1时，出现1的次数为  n / factor * factor + n % factor + 1 
当改为大于1时，出现1的次数为 n / factor * factor + factor

30143:
    由于3>1,则个位上出现1的次数为(3014+1) * 1
    由于4>1,则十位上出现1的次数为(301+1) * 10
    由于1=1，则百位上出现1次数为(30+0) * 100+(43+1)
    由于0<1，则千位上出现1次数为(3+0) * 1000
注:以百位为例，百位出现1为100~199，* 100的意思为单步出现了100~199，100次，* 30是因为出现了30次100~199,+(43+1)是因为左后一次 301** 不完整导致。

Solution:

```
public int countDigitOne(int n) {
    int count = 0;      //统计1出现的次数  
    int curr = 0;       //当前位 
    int base = 1;       //当前位的基  
    int remain = 0;     //当前位为1时，后面位剩余的数（即不完整的部分）中1出现的次数  
        
    while (n > 0) {
        curr = n % 10;
        n = n / 10;

        if (curr > 1) {
            count += n * base + base;
        } else if (curr == 1) {
            count += n * base + remain + 1;
        } else {
            count += n * base;
        }

        remain += curr * base;  //下一位要用到的基和剩余不完整部分值  
        base *= 10;
    }
    
    return count;
}
```