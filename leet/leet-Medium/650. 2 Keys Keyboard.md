Description:

Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:

Copy All: You can copy all the characters present on the notepad (partial copy is not allowed).
Paste: You can paste the characters which are copied last time.
Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'.

Example 1:
Input: 3
Output: 3
Explanation:
Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.
Note:
The n will be in the range [1, 1000].

Solution:

给了复制粘贴两个键，给了一个A，目标是利用这两个键打印出n个A，复制的时候全部复制，问，打印n个A需要操作多少步
这种有明显的递推特征的题，一定要尝试DP，
找规律最重要，DP要找出递推公式，如果无法发现内在的联系，递推公式就比较难写出来了，
从简单的例子开始分析，试图找到规律：
当n=1，已经有一个A了，不需要其他操作，返回0
当n=2，复制一次，粘贴一次，返回2
当n=3，复制一次，粘贴2次，返回3
当n=4，复制一次，粘贴3次，返回4 或 复制一次，粘贴一次，复制一次，粘贴一次 返回4
当n=5，复制一次，粘贴4次，返回5
当n=6，复制一次，粘贴2次，即AAA，复制一次，粘贴一次，返回5 或 复制一次，粘贴一次，复制一次，粘贴2次，返回5
对于任意一个n,最差的情况不会多于n步，但有可能小于n步，对于n=6,两种都是5次，2* 3，或3* 2, 要找到所有的因子，这个因子可以当做模块的个数，

```java
public int minSteps(int n) {
    int[] f = new int[n + 1];
    
    for (int i = 2; i <= n; i++) {
        f[i] = i;
        for (int j = 2; j < i; j++) {
            if (i % j == 0) {
                f[i] = Math.min(f[i], f[j] + f[i / j]);
            }
        }
    }
    
    return f[n];
}
```