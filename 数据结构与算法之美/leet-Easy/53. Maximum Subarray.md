Description:

Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:
```
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```
Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

Solution:

1. 动归
状态转移方程： f[i]=max(f[i-1] + nums[i], nums[i])
```java
public int maxSubArray(int[] nums) {
	if (nums == null || nums.length == 0) return 0;

	int[] f = new int[nums.length];
	int max = nums[0];

	for (int i = 0; i < nums.length; i++) {
		f[i] = Math.max(f[i - 1] + nums[i], nums[i]);
		max = Math.max(max, f[i]);
	}

	return max;
}
```

2. 数组缩减为一个变量
```java
public int maxSubArray(int[] nums) {
	if (nums == null || nums.length == 0) return 0;

	int f = 0;
	int max = nums[0];

	for (int i = 0; i < nums.length; i++) {
		f = Math.max(f + nums[i], nums[i]);
		max = Math.max(max, f);
	}

	return max;
}
```

3. 迭代
实现额外功能，记录最大子串的开始，结束位置
```java
public int maxSubArray(int[] nums) {
    if (nums == null || nums.length == 0) return 0;

    int f = 0;
    int max = nums[0];
    
    int start = 0, end = 0;
    
    for (int i = 0; i < nums.length; i++) {
        if (f + nums[i] > nums[i]) {
            f = f +nums[i];
            if (f > max) {
                end = i;
            }
        } else {
            f = nums[i];
            if (f > max) {
                start = i;
            }
        }
        
        max = Math.max(max, f);
    }
    System.out.println(start +"--" + end);
    
    return max;
    }
```
